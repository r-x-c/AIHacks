import base64
import json
import logging
import os
import requests
import urlparse

logger = logging.getLogger('clarifai')
logger.handlers = []
logger.addHandler(logging.StreamHandler())
logger.setLevel(logging.INFO)

logging.getLogger("requests").setLevel(logging.WARNING)

class TokenError(Exception):
  pass

class ApiError(Exception):

  def __init__(self, resource, params, method, response):
    self.resource = resource
    self.params = params
    self.method = method
    self.response = response
    msg = "%s %s FAILED. code: %d, reason: %s, response:%s" % (
      method, resource, response.status_code, response.reason,
      str(response.json()))
    super(ApiError, self).__init__(msg)

  # def __str__(self):
  #   parent_str = super(ApiError, self).__str__()
  #   return parent_str + str(self.json)

class UserError(Exception):
  pass



class ApiClient(object):
  """ Handles auth and making requests for you.

  The constructor for API access. You must sign up at developer.clarifai.com first and create an
  application in order to generate your credentials for API access.

  Args:
    self: instance of ApiClient
    client_id: the client_id for an application you've created in your Clarifai account.
    client_secret: the client_secret for the same application.
    base_url: Base URL of the API endpoints.
    quiet: if True then silence debug prints.
  """
  def __init__(self, client_id=None, client_secret=None,
               base_url=None, quiet=True):
    if client_id is None:
      logger.info("Using env variables for id and secret")
      client_id = os.environ['CLARIFAI_APP_ID']
      client_secret = os.environ['CLARIFAI_APP_SECRET']
    if base_url is None:
      base_url = os.environ.get('CLARIFAI_API_BASE', "api2-prod.clarifai.com")
    self.client_id = client_id
    self.client_secret = client_secret
    if quiet:
      logger.setLevel(logging.INFO)
    else:
      logger.setLevel(logging.DEBUG)

    parsed = urlparse.urlparse(base_url)
    scheme = 'https' if parsed.scheme == '' else parsed.scheme
    base_url = parsed.path if not parsed.netloc else parsed.netloc
    self.scheme = scheme
    self.base_url = base_url
    self.basev2 = os.path.join(scheme + '://', base_url)
    logger.debug("Base url: %s", self.basev2)
    self.token = None
    self.headers = None
    # Make sure when you create a client, it's ready for requests.
    self.get_token()

  def get_token(self):
    ''' Get an access token using your app_id and app_secret.

    You shouldn't need to call this method yourself. If there is no access token yet, this method
    will be called when a request is made. If a token expires, this method will also automatically
    be called to renew the token.

    '''
    # Get tokens from v1
    data = {'grant_type': 'client_credentials',
            'client_id': self.client_id,
            'client_secret': self.client_secret}
    # Get tokens from v2 (basic auth in url instead).
    data = {'grant_type': 'client_credentials'}
    logger.debug("get_token: %s data: %s",
                 os.path.join(self.basev2, "v2", "token/"), data)
    res = requests.post(os.path.join("%s://%s:%s@%s" % (self.scheme,
      self.client_id, self.client_secret, self.base_url), "v2", "token/"), data=data)
    if res.status_code == 200:
      logger.info("Got V2 token: %s", res.json())
      self.token = res.json()['access_token']
      self.headers = {'Authorization': "Bearer %s" % self.token}
    else:
      raise TokenError("Could not get a new token for v2: %s", str(res.json()))
    return res.json()

  def _check_token(self):
    if self.token is None:
      self.get_token()

  def _requester(self, resource, params, method, version="v2", files=None):
    ''' Obtains info and verifies user via Token Decorator

    Args:
      resource:
      params: parameters passed to the request
      version: v1 or v2
      method: GET or POST

    Returns:
      JSON from user request
    '''
    self._check_token()
    url = os.path.join(self.basev2, version, resource)
    # If 200 return, otherwise see if we need another token then retry.
    status_code = 199
    attempts = 1
    headers = {}
    while status_code != 200 and attempts > 0:
      if method == 'GET':
        headers = {'Content-Type': 'application/json',
                   'Authorization': self.headers['Authorization']}
        res = requests.get(url, params=params, headers=headers)
      elif method == "POST":
        if files:
          headers = {'Authorization': self.headers['Authorization']}
          # Seek back to the start.
          for f in files.itervalues():
            f.seek(0)
          res = requests.post(url, data=params, headers=headers, files=files)
        else:
          headers = {'Content-Type': 'application/json',
                     'Authorization': self.headers['Authorization']}
          res = requests.post(url, data=json.dumps(params), headers=headers)
      elif method == "DELETE":
        headers = {'Content-Type': 'application/json',
                   'Authorization': self.headers['Authorization']}
        res = requests.delete(url, data=json.dumps(params), headers=headers)
      elif method == "PATCH":
        headers = {'Content-Type': 'application/json',
                   'Authorization': self.headers['Authorization']}
        res = requests.patch(url, data=json.dumps(params), headers=headers)
      else:
        raise UserError("Unsupported request type: '%s'" % method)
      logger.debug("\n%s\n: url: %s\n data: %s\n headers: %s",
                   method, url, params, headers)
      logger.debug("\nRESULT:\n%s", res.content)
      try:
        js = res.json()
      except Exception:
        logger.exception("Could not get json from non-200 response.")
        return res
      if isinstance(js, dict) and js.get('status_code', None) == "TOKEN_EXPIRED":
        self.get_token()
      status_code = res.status_code
      attempts -= 1
    if res.status_code != 200:
      raise ApiError(resource, params, method, res)
    return res

  def get(self, resource, params=None, version="v2"):
    """ Authorized get from Clarifai's API. """
    return self._requester(resource, params, 'GET', version)

  def post(self, resource, params=None, version="v2"):
    """ Authorized post to Clarifai's API. """
    return self._requester(resource, params, 'POST', version)

  def post_form(self, resource, params=None, version="v2"):
    """ Authorized post to Clarifai's API. """
    return self._requester(resource, params=None, method='POST', version=version, files=params)

  def delete(self, resource, params=None, version="v2"):
    """ Authorized get from Clarifai's API. """
    return self._requester(resource, params, 'DELETE', version)

  def patch(self, resource, params=None, version="v2"):
    """ Authorized patch from Clarifai's API """
    return self._requester(resource, params, 'PATCH', version)

  def addInputs(self, objs):
    ''' Add a list of Images or Videos to an application.

    Args:
      obj: A list of Image or Video objects.
    '''
    if not isinstance(objs, list):
      raise UserError("objs must be a list")
    if not isinstance(objs[0], (Image, Video)):
      raise UserError("Not valid type of content to add. Must be Image or Video")

    resource = "inputs"
    data = {"inputs": [obj.dict() for obj in objs]}
    res = self.post(resource, data)
    return res.json()

  def addInputsFile(self, file_obj, file_type):
    ''' Add a list of Images or Videos to an application.

    Args:
      csv_tsv_file_obj: A list of Image or Video objects.
      file_type: the type of file to upload. Must be 'csv' or 'tsv'
    '''
    if not hasattr(file_obj, 'read') and not hasattr(file_obj, 'getvalue'):
      raise UserError("file_obj must be an open file object")
    if file_type not in ['csv', 'tsv']:
      raise Exception("file_type must be one of 'csv' or 'tsv'")

    resource = "inputs/file"
    data = {file_type: file_obj}
    res = self.post_form(resource, data)
    return res.json()


  def searchInputs(self, image=None, and_terms=None, or_terms=None,
                   not_terms=None, page=1, per_page=20):
    ''' Search an application and get predictions (optional)

    Args:
      image: An Image object you want query the application by.
      and_terms: list of All predictions to match
      or_terms: list of Any predictions to match
      not_terms: list of predictions to NOT match
      page: the page of results to get, starts at 1.
      per_page: number of results returned per page
    '''
    if image is not None and not isinstance(image, (Image, Video)):
      raise UserError("Not valid type of content to add. Must be Image or Video")

    resource = "searches/"

    # Similar image search and predictions
    d = {'pagination': Pagination(page, per_page).dict()}

    query = {}
    query['stanzas'] = []

    # query by image
    if image is not None:
      condition = image.dict()

      condition.update({"source": {
                            "model_query": {
                                "type": "visual"
                                }
                            }
                       })
      query['stanzas'].append(condition)

    # query by AND and NOT terms
    if and_terms is not None:
      and_terms = [(term, True) for term in and_terms]
    else:
      and_terms = []

    if not_terms is not None:
      not_terms = [(term, False) for term in not_terms]
    else:
      not_terms = []

    and_not_terms = and_terms + not_terms

    if and_not_terms:
      condition = { "source": {
                        "model_query": {
                            "type": "concept"
                        }
                    },
                    "data": {
                        "tags": [{"concept":{"name":term}, "value":value} for term, value in and_not_terms]
                    }
                  }
      query['stanzas'].append(condition)

    if or_terms is not None:
      condition = { "source": {
                        "model_query": {
                            "type": "concept"
                        }
                    },
                    "data": {
                        "tags": [{"concept":{"name":term}} for term in or_terms]
                    }
                  }
      query['stanzas'].append(condition)

    if len(query['stanzas']) > 0:
      d['query'] = query

    res = self.post(resource, d)
    return res.json()


  def getInput(self, ID):
    ''' Get a single image by it's id.

    Args:
      ID: the id of the Image.
    '''

    resource = "inputs/%s" % ID
    res = self.get(resource)
    return res.json()


  def getInputs(self, page=1, per_page=20):
    ''' List all images for the Application.

    Args:
      page: the page of results to get, starts at 1.
      per_page: number of results returned per page
    '''

    resource = "inputs"
    d = {'page': page, 'per_page': per_page}
    res = self.get(resource, d)
    return res.json()


  def getInputsStatus(self):
    ''' Return counts of images in the Application.

    '''

    resource = "inputs/status"
    res = self.get(resource)
    return res.json()


  def deleteInput(self, ID):
    ''' Delete a single image by it's id.

    Args:
      ID: the id of the input
    '''

    resource = "inputs/%s" % ID
    res = self.delete(resource)
    return res.json()

  def updateInput(self, ID, labels=None, not_labels=None):
    ''' update the labels for a given image '''

    # query by AND and NOT terms
    if labels is not None:
      pos_terms = [(term, True) for term in labels]
    else:
      pos_terms = []

    if not_labels is not None:
      neg_terms = [(term, False) for term in not_labels]
    else:
      neg_terms = []

    terms = pos_terms + neg_terms

    resource = "inputs/%s" % ID

    data = {'input': {
               'id': ID,
               'data': {
                  'tags': [{'concept': {'id': name }, 'value': val} for name, val in terms]
               }
             }
           }

    res = self.patch(resource, data)
    return res.json()

  def getModels(self, page=1, per_page=20):
    ''' get all models '''

    resource = "models"
    params = {'page': page,
              'per_page': per_page
             }

    res = self.get(resource, params)
    return res.json()

  def getModel(self, id, output_info=False):
    ''' get model info '''
    if output_info is False:
      return self._getModelByID(id)
    else:
      return self._getModelOutputByID(id)

  def _getModelByID(self, id=None):
    ''' get model id by model id '''

    resource = "models/%s" % id

    res = self.get(resource)
    return res.json()

  def _getModelOutputByID(self, id=None):
    ''' get model output info by model id '''

    resource = "models/%s/output_info" % id

    res = self.get(resource)
    return res.json()

  def getModelVersions(self, id, page=1, per_page=20):
    ''' get model vesions '''

    resource = "models/%s/versions" % id
    params = {'page': page,
              'per_page': per_page
             }

    res = self.get(resource, params)
    return res.json()

  def getModelVersion(self, id, version):
    ''' get model info for a specific model version '''

    resource = "models/%s/versions/%s" % (id, version)

    res = self.get(resource)
    return res.json()

  def searchModels(self, name=None, model_type=None):
    ''' search model by name and type '''

    resource = "models/searches"

    if name is not None and model_type is not None:
      data = {"model_query": {
                "name": name,
                "type": model_type
                }
             }
    elif name is None and model_type is not None:
      data = {"model_query": {
                "type": model_type
                }
             }
    elif name is not None and model_type is None:
      data = {"model_query": {
                "name": name
                }
             }
    else:
      data = {}

    res = self.post(resource, data)
    return res.json()

  def createModel(self, model_name, concept_ids, one_vs_all=False):
    ''' create custom model '''

    resource = "models"
    data = {
             "model": {
               "name": model_name,
               "input_info": {
                 "image_input_info": {}
               },
               "output_info": {
                 "concept_output_info": {
                   "concepts": [ {"id":concept_id} for concept_id in concept_ids ],
                   "one_vs_all": one_vs_all
                 }
               }
             }
           }

    res = self.post(resource, data)
    return res.json()

  def trainModel(self, model_id):
    ''' train for a model '''

    resource = "models/%s/versions" % model_id

    res = self.post(resource)

    return res.json()

  def predictModel(self, model_id, objs, version_id=None):

    resource = "models/%s/outputs" % model_id
    if not isinstance(objs, list):
      raise UserError("objs must be a list")
    if not isinstance(objs[0], (Image, Video)):
      raise UserError("Not valid type of content to add. Must be Image or Video")

    data = {"inputs": [obj.dict() for obj in objs]}
    res = self.post(resource, data)
    return res.json()

  def predictConcepts(self, objs):

    models = self.searchModels(name='general-v1.3', model_type='concept')
    model = models['models'][0]
    model_id = model['id']

    return self.predictModel(model_id, objs)

  def predictColors(self, objs):

    models = self.searchModels(name='color', model_type='color')
    model = models['models'][0]
    model_id = model['id']

    return self.predictModel(model_id, objs)

  def predictFaces(self, objs):

    models = self.searchModels(name='face-detect')
    model = models['models'][0]
    model_id = model['id']

    return self.predictModel(model_id, objs)

  def predictCluster(self, objs, model='general-v1.3'):

    models = self.searchModels(name=model, model_type='cluster')
    model = models['models'][0]
    model_id = model['id']

    return self.predictModel(model_id, objs)

  def predictEmbed(self, objs, model='general-v1.3'):

    models = self.searchModels(name=model, model_type='embed')
    model = models['models'][0]
    model_id = model['id']

    return self.predictModel(model_id, objs)

  def predictFocus(self, objs):

    models = self.searchModels(model_type='blur')
    model = models['models'][0]
    model_id = model['id']

    return self.predictModel(model_id, objs)

class Pagination(object):
  def __init__(self, page=1, per_page=20):
    self.page = page
    self.per_page = per_page
  def dict(self):
    return {'page': self.page, 'per_page': self.per_page}


class Asset(object):
  def __init__(self, url=None, file_obj=None, ID=None, crop=None, labels=None, not_labels=None):
    ''' Construct an Image/Video object. it must have one of url or file_obj set.
    Args:
      url: the url to a publically accessible image.
      file_obj: a file-like object in which read() will give you the bytes.
      ID: unique id to set for the image. If None then the server will create and return one for
    you.
      crop: a list of float in the range 0-1.0 in the order [top, left, bottom, right] to crop out
    the asset before use.
      labels: a list of labels this asset associate with
      not_labels: a list of labels this asset does not associate with
    '''
    if ((url is not None and file_obj is not None) or
        (url is None and file_obj is None)):
      raise UserError("You must only set one of: [url, file_obj] argumets.")
    if crop is not None and (not isinstance(crop, list) or len(crop) != 4):
      raise UserError("crop arg must be list of 4 floats or None")
    self.url = url
    self.file_obj = file_obj
    self.crop = crop
    self.ID = ID
    self.labels = labels
    self.not_labels = not_labels

  def dict(self):
    ''' Return the data of the Asset as a dict ready to be input to json.dumps. '''
    data = {'data':{ 'image': {} }}

    if self.file_obj is not None:
      if hasattr(self.file_obj, 'read'):
        data['data']['image']['base64'] = base64.b64encode(self.file_obj.read()).decode('UTF-8')
      elif hasattr(self.file_obj, 'getvalue'):
        data['data']['image']['base64'] = base64.b64encode(self.file_obj.getvalue()).decode('UTF-8')
      else:
        raise UserError("Not sure how to read your file_obj")
    else:
      data['data']['image']['url'] = self.url

    if self.ID is not None:
      data['id'] = self.ID

    if self.crop is not None:
      data['data']['image']['crop'] = self.crop

    # fill the tags
    if self.labels is not None:
      pos_terms = [(term, True) for term in self.labels]
    else:
      pos_terms = []

    if self.not_labels is not None:
      neg_terms = [(term, False) for term in self.not_labels]
    else:
      neg_terms = []

    terms = pos_terms + neg_terms
    if terms:
      data['data']['tags'] = [{'concept':{'id':name}, 'value':value} for name, value in terms]

    return data

class Image(Asset):
  pass

class Video(Asset):
  pass
